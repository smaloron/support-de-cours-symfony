<!DOCTYPE html SYSTEM "about:legacy-compat">
<html lang="en-US" data-preset="contrast" data-primary-color="#307FFF"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="UTF-8"><meta name="robots" content="noindex"><meta name="built-on" content="2025-02-01T10:46:57.441619"><title>Routes et contr&ocirc;leurs | Symfony support</title><script type="application/json" id="virtual-toc-data">[{"id":"objectif","level":0,"title":"Objectif","anchor":"#objectif"},{"id":"un-peu-d-histoire","level":0,"title":"Un peu d’histoire","anchor":"#un-peu-d-histoire"},{"id":"le-principe-du-routing","level":0,"title":"Le principe du routing","anchor":"#le-principe-du-routing"},{"id":"utilisation-de-la-requ-te","level":0,"title":"Utilisation de la requête","anchor":"#utilisation-de-la-requ-te"},{"id":"les-param-tres","level":0,"title":"Les paramètres","anchor":"#les-param-tres"},{"id":"pr-fixage-des-routes","level":0,"title":"Préfixage des routes","anchor":"#pr-fixage-des-routes"},{"id":"liste-des-routes","level":0,"title":"Liste des routes","anchor":"#liste-des-routes"},{"id":"exercices","level":0,"title":"Exercices","anchor":"#exercices"}]</script><script type="application/json" id="topic-shortcuts"></script><link href="https://resources.jetbrains.com/writerside/apidoc/6.10.0-b575/app.css" rel="stylesheet"><meta name="msapplication-TileColor" content="#000000"><link rel="apple-touch-icon" sizes="180x180" href="https://jetbrains.com/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="https://jetbrains.com/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="https://jetbrains.com/favicon-16x16.png"><meta name="msapplication-TileImage" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-144x144.png"><meta name="msapplication-square70x70logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-70x70.png"><meta name="msapplication-square150x150logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-150x150.png"><meta name="msapplication-wide310x150logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-310x150.png"><meta name="msapplication-square310x310logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-310x310.png"><meta name="image" content=""><!-- Open Graph --><meta property="og:title" content="Routes et contr&ocirc;leurs | Symfony support"><meta property="og:description" content=""><meta property="og:image" content=""><meta property="og:site_name" content="Symfony support Help"><meta property="og:type" content="website"><meta property="og:locale" content="en_US"><meta property="og:url" content="writerside-documentation//version 1/001-routes.html"><!-- End Open Graph --><!-- Twitter Card --><meta name="twitter:card" content="summary_large_image"><meta name="twitter:site" content=""><meta name="twitter:title" content="Routes et contr&ocirc;leurs | Symfony support"><meta name="twitter:description" content=""><meta name="twitter:creator" content=""><meta name="twitter:image:src" content=""><!-- End Twitter Card --><!-- Schema.org WebPage --><script type="application/ld+json">{
    "@context": "http://schema.org",
    "@type": "WebPage",
    "@id": "writerside-documentation//version 1/001-routes.html#webpage",
    "url": "writerside-documentation//version 1/001-routes.html",
    "name": "Routes et contr&ocirc;leurs | Symfony support",
    "description": "",
    "image": "",
    "inLanguage":"en-US"
}</script><!-- End Schema.org --><!-- Schema.org WebSite --><script type="application/ld+json">{
    "@type": "WebSite",
    "@id": "writerside-documentation/#website",
    "url": "writerside-documentation/",
    "name": "Symfony support Help"
}</script><!-- End Schema.org --></head><body data-id="001-routes" data-main-title="Routes et contrôleurs" data-article-props="{&quot;seeAlsoStyle&quot;:&quot;links&quot;}" data-template="article" data-breadcrumbs=""><div class="wrapper"><main class="panel _main"><header class="panel__header"><div class="container"><h3>Symfony support version 1 Help</h3><div class="panel-trigger"></div></div></header><section class="panel__content"><div class="container"><article class="article" data-shortcut-switcher="inactive"><h1 data-toc="001-routes" id="001-routes.md">Routes et contrôleurs</h1><section class="chapter"><h2 id="objectif" data-toc="objectif">Objectif</h2><p id="yexdr5_11">L&rsquo;objectif de ce document est de comprendre le fonctionnement du routing dans Symfony afin de cr&eacute;er des r&eacute;ponses que l&rsquo;on puisse appeler depuis un navigateur Web.</p></section><section class="chapter"><h2 id="un-peu-d-histoire" data-toc="un-peu-d-histoire">Un peu d&rsquo;histoire</h2><p id="yexdr5_12">Dans une application Web classique l&rsquo;adresse de chaque page correspond &agrave; un fichier sur le serveur. Un peu comme si le serveur Web &eacute;tait votre disque dur et que vous naviguiez dans cette arborescence.</p><p id="yexdr5_13">Cette fa&ccedil;on de faire tr&egrave;s populaire au d&eacute;but des ann&eacute;es&nbsp;2000 n&rsquo;a plus vraiment cours actuellement. Quasiment tous les projets adoptent d&eacute;sormais un syst&egrave;me de routage qui vise &agrave; d&eacute;coupler l&rsquo;adresse Web et la ressource vers laquelle elle pointe. C&rsquo;est bien entendu ce que propose Symfony.</p><figure id="yexdr5_14"><img alt="001-routing-http-classique.svg" src="images/001-routing-http-classique.png" title="001-routing-http-classique.svg" width="1786" height="664"></figure></section><section class="chapter"><h2 id="le-principe-du-routing" data-toc="le-principe-du-routing">Le principe du routing</h2><p id="yexdr5_15">Le routing ou aiguillage en fran&ccedil;ais consiste &agrave; faire correspondre une adresse (que l&rsquo;on appelle une route) avec une ressource. Les deux &eacute;l&eacute;ments ne sont toutefois pas intrins&egrave;quement li&eacute;s, en connaissant l&rsquo;adresse, on ne peut inf&eacute;rer la ressource sans passer par une table de correspondances.</p><p id="yexdr5_16">On peut faire une analogie avec un annuaire t&eacute;l&eacute;phonique. Rien dans le nom d&rsquo;une personne ne me permet de deviner son num&eacute;ro. Il me faut consulter l&rsquo;annuaire (la table de correspondance) pour obtenir l&rsquo;information d&eacute;sir&eacute;e.</p><p id="yexdr5_17">Avec Symfony, le routing fait donc correspondre une adresse (la partie de l&rsquo;URL apr&egrave;s le nom du serveur) avec une m&eacute;thode d&rsquo;une classe. On appelle ce type de classe un contr&ocirc;leur (le C du pattern MVC).</p><section class="chapter"><h3 id="le-contr-leur" data-toc="le-contr-leur">Le contr&ocirc;leur</h3><p id="yexdr5_19">Un contr&ocirc;leur Symfony est juste une classe qui poss&egrave;de au moins une m&eacute;thode retournant une r&eacute;ponse HTTP.</p><div class="code-block" data-lang="php">
&lt;?php

namespace App\Controller;

use Symfony\Component\HttpFoundation\Response;

class HomeController
{
    /**
     * Une route simple sans paramètres
     * @return Response
     */
    final public function index(): Response{
        return new Response(&quot;Hello Symfony&quot;);
    }
}
</div><p id="yexdr5_21">Il faut d&eacute;sormais ajouter les informations de routing pour &eacute;tablir la correspondance entre la m&eacute;thode <code class="code" id="yexdr5_27">index</code>du contr&ocirc;leur et une adresse qui sera tap&eacute;e das le navigateur Web.</p><p id="yexdr5_22">Symfony propose plusieurs fa&ccedil;ons de d&eacute;finir cette correspondance, concentrons-nous sur la plus populaire.</p><p id="yexdr5_23">Il s&rsquo;agit d&rsquo;ajouter des informations &agrave; la m&eacute;thode par le biais des attributs de PHP8.</p><div class="code-block" data-lang="php">
&lt;?php

namespace App\Controller;

use Symfony\Component\HttpFoundation\Response;
use Symfony\Component\Routing\Attribute\Route;

class HomeController
{
    /**
     * Une route simple sans paramètres
     * @return Response
     */
     #[Route('/hello')]
    final public function index(): Response{
        return new Response(&quot;Hello Symfony&quot;);
    }
}
</div><p id="yexdr5_25">Ici deux choses ont chang&eacute;&nbsp;:</p><ul class="list _bullet" id="yexdr5_26"><li class="list__item" id="yexdr5_28"><p>Import de la classe <code class="code" id="yexdr5_30">Symfony\Component\Routing\Attribute\Route;</code></p></li><li class="list__item" id="yexdr5_29"><p>Ajout d&rsquo;un attribut&nbsp;PHP8 avec l&rsquo;appel de la fonction Route au-dessus de la m&eacute;thode <code class="code" id="yexdr5_31">index</code>qui fait correspondre l&rsquo;adresse pass&eacute;e en argument avec la m&eacute;thode de la classe.</p></li></ul></section></section><section class="chapter"><h2 id="utilisation-de-la-requ-te" data-toc="utilisation-de-la-requ-te">Utilisation de la requ&ecirc;te</h2><p id="yexdr5_32">Avez-vous remarqu&eacute; que parfois les adresses Web se terminent par une suite d&rsquo;informations qui ressemblent &agrave; ceci ?</p><div class="code-block" data-lang="none">
http://monserveur.com/contact?id=7
</div><p id="yexdr5_34">La partie apr&egrave;s le <code class="code" id="yexdr5_39">?</code>correspond &agrave; des param&egrave;tres pass&eacute;s &agrave; la route. Un peu comme les arguments d&rsquo;une fonction. On appelle cette derni&egrave;re partie de l&rsquo;URL la cha&icirc;ne de requ&ecirc;te ou query string.</p><p id="yexdr5_35">Pour exploiter ce type d&rsquo;information, il faut importer une nouvelle classe, l&rsquo;objet Request.</p><p id="yexdr5_36">Ensuite en argument de la m&eacute;thode, il faut ajouter l&rsquo;objet Request. C&rsquo;est Symfony qui se chargera d&rsquo;ex&eacute;cuter la m&eacute;thode et d&rsquo;ajouter une instance de cet objet. Toutefois, pour qu&rsquo;il sache quelle classe instancier il faut quand m&ecirc;me lui pr&eacute;ciser le type de la variable <code class="code" id="yexdr5_40">$request</code>.</p><p id="yexdr5_37">Enfin, la m&eacute;thode <code class="code" id="yexdr5_41">get</code>de l&rsquo;objet <code class="code" id="yexdr5_42">Request</code>permet de r&eacute;cup&eacute;rer la valeur d&rsquo;un param&egrave;tre du query string.</p><div class="code-block" data-lang="php">
&lt;?php

namespace App\Controller;

use Symfony\Component\HttpFoundation\Response;
use Symfony\Component\Routing\Attribute\Route;
use Symfony\Component\HttpFoundation\Request;

class HomeController
{
    /**
     * Cette route admet en argument la Requête HTTP,
     * cela permet de récupérer des données passées dans l'URL
     * L'objet Request de Symfony simplifie cette récupération 
     * en proposant une méthode get
     * qui interroge tout ce qui est récupérable 
     * dans la requête HTTP
     *
     * @param Request $request
     * @return Response
     *
     * exemple : /bonjour?name=Alice
     */
    #[Route('/bonjour')]
    final public function bonjour(Request $request): Response{
        // L'opérateur ?? définit une valeur par défaut 
        // si la méthode get retourne null
        $name = $request-&gt;get(&quot;name&quot;) ?? &quot;inconnu&quot;;
        return new Response(&quot;Bonjour $name&quot;);
    }
}
</div></section><section class="chapter"><h2 id="les-param-tres" data-toc="les-param-tres">Les param&egrave;tres</h2><p id="yexdr5_43">En plus du query string, Symfony, propose une autre m&eacute;thode pour passer des param&egrave;tres &agrave; une route. Cette derni&egrave;re consiste &agrave; d&eacute;finir que la partie finale de la route correspondra aux valeurs des param&egrave;tres que nous souhaitons passer &agrave; la fonction.</p><p id="yexdr5_44">On obtient donc ceci&nbsp;:</p><div class="code-block" data-lang="none">
/hello/Pierre
</div><p id="yexdr5_46">Au lieu de cela&nbsp;:</p><div class="code-block" data-lang="none">
/hello?name=Pierre
</div><p id="yexdr5_48">Pour d&eacute;finir un param&egrave;tre, il faut le d&eacute;clarer &agrave; la fois dans la route et dans les arguments de la fonction. Mais attention le nom du param&egrave;tre doit &ecirc;tre identique &agrave; ces deux endroits.</p><div class="code-block" data-lang="php">
    /**
     * Cette route possède un paramètre passé dans l'url 
     * (en dehors du querystring)
     * Remarquez que le nom du paramètre 
     * doit correspondre au nom de l'argument 
     * passé à la fonction (ici name et $name)
     *
     * @param string $name
     * @return Response
     */
    #[Route('/hello/{name}')]
    final public function hello(string $name): Response{
        return new Response(&quot;Hello $name&quot;);
    }
</div><section class="chapter"><h3 id="valeur-par-d-faut" data-toc="valeur-par-d-faut">Valeur par d&eacute;faut</h3><p id="yexdr5_54">Pour d&eacute;finir une valeur par d&eacute;faut, il suffit de l&rsquo;indiquer dans la signature de la fonction.</p><div class="code-block" data-lang="php">
    /**
     * Cette route possède un paramètre passé dans l'url 
     * (en dehors du querystring)
     * Remarquez que le nom du paramètre 
     * doit correspondre au nom de l'argument 
     * passé à la fonction (ici name et $name)
     *
     * @param string $name
     * @return Response
     */
    #[Route('/hello/{name}')]
    final public function hello(string $name = ''): Response{
        return new Response(&quot;Hello $name&quot;);
    }
</div></section><section class="chapter"><h3 id="param-tres-ou-querystring" data-toc="param-tres-ou-querystring">Param&egrave;tres ou querystring</h3><p id="yexdr5_56">Les deux techniques produisent le m&ecirc;me effet. On peut donc se poser la question de la pertinence d&rsquo;utiliser l&rsquo;une ou l&rsquo;autre.</p><p id="yexdr5_57">Les param&egrave;tres produisent des URL plus propres et explicites, dans la plupart des cas, on les pr&eacute;f&eacute;rera au query string.</p><p id="yexdr5_58">Le query string peut &ecirc;tre int&eacute;ressant lorsque l&rsquo;information qu&rsquo;il donne est facultative, par exemple pour indiquer le num&eacute;ro de la page en cours dans un affichage pagin&eacute; ou bien un ordre de tri ou encore un filtre. Bref, dans les cas o&ugrave; les informations suppl&eacute;mentaires ne sont pas indispensables au bon fonctionnement de la route.</p><div class="code-block" data-lang="php">
&lt;?php

namespace App\Controller;

use Symfony\Component\HttpFoundation\Response;
use Symfony\Component\Routing\Attribute\Route;
use Symfony\Component\HttpFoundation\Request;

class HomeController
{
    /**
     * @param Request $request
     * @return Response
     *
     * exemple : 
     * /liste
     * /liste?page=5
     */
    #[Route('/liste')]
    final public function bonjour(Request $request): Response{
        $page = $request-&gt;get(&quot;page&quot;) ?? 1;
        return new Response(&quot;Vous êtes sur la page $page&quot;);
    }
}
</div></section><section class="chapter"><h3 id="contraindre-les-param-tres" data-toc="contraindre-les-param-tres">Contraindre les param&egrave;tres</h3><p id="yexdr5_60">Les param&egrave;tres poss&egrave;dent un avantage suppl&eacute;mentaire par rapport au query string, il est possible de contraindre la valeur d&rsquo;un param&egrave;tre. En fait, nous avons m&ecirc;me deux m&eacute;thodes pour d&eacute;finir cette contrainte. La premi&egrave;re m&eacute;thode consiste tout simplement &agrave; typer l&rsquo;argument de la fonction. La seconde consiste &agrave; d&eacute;finir une expression r&eacute;guli&egrave;re dans les attributs&nbsp;PHP8 par le biais du tableau<code class="code" id="yexdr5_62">requirements</code>.</p><section class="chapter"><h4 id="typage" data-toc="typage">Typage</h4><p id="yexdr5_63">Ici le param&egrave;tre <code class="code" id="yexdr5_65">$id</code>doit &ecirc;tre un entier. Si tel n&rsquo;est pas le cas, on obtient une erreur de typage.</p><div class="code-block" data-lang="php">
    /**
     * @param string $name
     * @return Response
     */
    #[Route('/details/{id}')]
    final public function hello(int $id = ''): Response{
        return new Response(&quot;Vous êtes sur la fiche $id&quot;);
    }
</div></section></section><section class="chapter"><h3 id="requirements" data-toc="requirements">Requirements</h3><p id="yexdr5_66">Ici, le param&egrave;tre <code class="code" id="yexdr5_70">id</code>doit correspondre &agrave; l&rsquo;expression r&eacute;guli&egrave;re <code class="code" id="yexdr5_71">\d+</code> (uniquement des chiffres). Si tel n&rsquo;est pas le cas, la route n&rsquo;est pas valide et le routeur passe &agrave; la route suivante pour tenter de r&eacute;soudre le routing.</p><div class="code-block" data-lang="php">
    /**
     * @param string $name
     * @return Response
     */
    #[Route('/details/{id}', requirements: ['id'=&gt;'\d+'])]
    final public function hello($id = ''): Response{
        return new Response(&quot;Vous êtes sur la fiche $id&quot;);
    }
</div><p id="yexdr5_68">Depuis Symfony 6.2 on dispose d'une suite d'expressions r&eacute;guli&egrave;re pr&eacute;d&eacute;finies dans l'&eacute;num&eacute;ration de la classe Requirement.</p><div class="code-block" data-lang="php">
    /**
     * @param string $name
     * @return Response
     */
    #[Route('/details/{id}', requirements: ['id'=&gt;Requirement::DIGITS])]
    final public function hello($id = ''): Response{
        return new Response(&quot;Vous êtes sur la fiche $id&quot;);
    }
</div></section></section><section class="chapter"><h2 id="pr-fixage-des-routes" data-toc="pr-fixage-des-routes">Pr&eacute;fixage des routes</h2><p id="yexdr5_72">Si l&rsquo;ensemble des routes dans le m&ecirc;me contr&ocirc;leur partage, certaines caract&eacute;ristiques, on peut alors d&eacute;finir ces &eacute;l&eacute;ments communs dans un attribut&nbsp;PHP8 plac&eacute; au-dessus de la classe. On &eacute;vite ainsi d&rsquo;avoir &agrave; ressaisir ces informations autant de fois qu&rsquo;il y a de routes dans la classe.</p><p id="yexdr5_73">Ici, les routes finales sont constitu&eacute;es de la combinaison de la route, de la classe et de celle de la m&eacute;thode.</p><div class="code-block" data-lang="none">
/home/hello
/home/details/{id}
/home/liste
</div><div class="code-block" data-lang="php">
&lt;?php

namespace App\Controller;

use Symfony\Component\HttpFoundation\Response;
use Symfony\Component\Routing\Attribute\Route;
use Symfony\Component\HttpFoundation\Request;

#[Route('/home')]
class HomeController
{

    #[Route('/hello/{name}')]
    final public function hello(string $name = ''): Response{
        return new Response(&quot;Hello $name&quot;);
    }
    
    #[Route('/details/{id}')]
    final public function hello(int $id = ''): Response{
        return new Response(&quot;Vous êtes sur la fiche $id&quot;);
    }
    
    #[Route('/liste')]
    final public function bonjour(Request $request): Response{
        $page = $request-&gt;get(&quot;page&quot;) ?? 1;
        return new Response(&quot;Vous êtes sur la page $page&quot;);
    }
}
</div></section><section class="chapter"><h2 id="liste-des-routes" data-toc="liste-des-routes">Liste des routes</h2><p id="yexdr5_76">C&rsquo;est vraiment tr&egrave;s pratique d&rsquo;avoir la d&eacute;finition de la route. Juste &agrave; c&ocirc;t&eacute; de la fonction que cette route va invoquer. Cependant, on a parfois envie de lister l&rsquo;ensemble des routes de notre application. Pour cela Symfony nous propose une commande console.</p><div class="code-block" data-lang="none">
symfony console debug:router --show-controllers
</div><div class="code-block" data-lang="bash">
  Name               Method   Scheme   Host   Path                       Controller                                
 ------------------ -------- -------- ------ -------------------------- ------------------------------------------ 
  _preview_error     ANY      ANY      ANY    /_error/{code}.{_format}   error_controller::preview()               
  app_home_index     ANY      ANY      ANY    /home                      App\Controller\HomeController::index()    
  app_home_bonjour   ANY      ANY      ANY    /bonjour                   App\Controller\HomeController::bonjour()  
  app_home_hello     ANY      ANY      ANY    /hello/{name}              App\Controller\HomeController::hello()    
  app_home_add       ANY      ANY      ANY    /add/{n1}/{n2}             App\Controller\HomeController::add()      
 ------------------ -------- -------- ------ -------------------------- ------------------------------------------ 
</div><p id="yexdr5_79">On peut constater deux choses&nbsp;:</p><ul class="list _bullet" id="yexdr5_80"><li class="list__item" id="yexdr5_83"><p>L&rsquo;ordre des routes suit celui de la cr&eacute;ation des contr&ocirc;leurs et des m&eacute;thodes</p></li><li class="list__item" id="yexdr5_84"><p>Les routes poss&egrave;dent un nom automatiquement attribu&eacute; par Symfony</p></li></ul><section class="chapter"><h3 id="changer-le-nom-d-une-route" data-toc="changer-le-nom-d-une-route">Changer le nom d&rsquo;une route</h3><p id="yexdr5_85">C&rsquo;est tr&egrave;s simple, il suffit d&rsquo;ajouter une clef <code class="code" id="yexdr5_88">name</code></p><div class="code-block" data-lang="php">

    #[Route('/hello/{name}', name: 'hello')]
    final public function hello(string $name = ''): Response{
        return new Response(&quot;Hello $name&quot;);
    }

</div><p id="yexdr5_87">Relancer la commande console pour constater le changement.</p></section><section class="chapter"><h3 id="changer-l-ordre-des-routes" data-toc="changer-l-ordre-des-routes">Changer l&rsquo;ordre des routes</h3><p id="yexdr5_89">L&rsquo;ordre des routes est important, car c&rsquo;est dans cet ordre que le routeur de Symfony va analyser chaque route pour s&rsquo;arr&ecirc;ter &agrave; la premi&egrave;re qui correspond &agrave; l&rsquo;URL. Voil&agrave; pourquoi il est conseill&eacute; de d&eacute;finir les routes les plus sp&eacute;cifiques en premier.</p><p id="yexdr5_90">On peut forcer l&rsquo;ordre des routes en ajoutant une clef Priority dans les attributs&nbsp;PHP8. La valeur de cette clef est un entier et les r&egrave;gles sont les suivantes&nbsp;:</p><ul class="list _bullet" id="yexdr5_91"><li class="list__item" id="yexdr5_93"><p>Les routes sont ordonn&eacute;es par ordre d&eacute;croissant de priorit&eacute; (la plus haute en premier).</p></li><li class="list__item" id="yexdr5_94"><p>Les routes qui n&rsquo;ont pas de priorit&eacute; sont class&eacute;es apr&egrave;s celles qui en ont une.</p></li></ul><div class="code-block" data-lang="php">
&lt;?php

namespace App\Controller;

use Symfony\Component\HttpFoundation\Response;
use Symfony\Component\Routing\Attribute\Route;
use Symfony\Component\HttpFoundation\Request;

#[Route('/home')]
class HomeController
{

    #[Route('/hello/{name}')]
    final public function hello(string $name = ''): Response{
        return new Response(&quot;Hello $name&quot;);
    }
    
    #[Route('/details/{id}', priority: 1)]
    final public function hello(int $id = ''): Response{
        return new Response(&quot;Vous êtes sur la fiche $id&quot;);
    }
    
    #[Route('/liste', priority: 2)]
    final public function bonjour(Request $request): Response{
        $page = $request-&gt;get(&quot;page&quot;) ?? 1;
        return new Response(&quot;Vous êtes sur la page $page&quot;);
    }
}
</div></section></section><section class="chapter"><h2 id="exercices" data-toc="exercices">Exercices</h2><section class="procedure-steps" id="yexdr5_95"><ol class="list _decimal"><li class="list__item" id="yexdr5_96"><p>Cr&eacute;er un contr&ocirc;leur `CalcController` avec un pr&eacute;fixe `/calcul`</p></li><li class="list__item" id="yexdr5_97"><p>Cr&eacute;er une route `/addition/{n1}/{n2}` qui admet deux arguments et affiche l&rsquo;addition de ces deux &eacute;l&eacute;ments.</p></li><li class="list__item" id="yexdr5_98"><p>Cr&eacute;er une route `/soustraction/{n1}/{n2}` qui admet deux arguments et affiche la soustraction de ces deux &eacute;l&eacute;ments.</p></li><li class="list__item" id="yexdr5_99"><p>Cr&eacute;er une route `/{n1}/puissance/{n2}` qui admet deux arguments et affiche l&rsquo;&eacute;l&eacute;ment n1 &eacute;lev&eacute; &agrave; la puissance n2.</p></li><li class="list__item" id="yexdr5_100"><p>Placer la route `puissance` en premier et tester toutes les routes sans `requirements`, que constatez-vous ?</p></li><li class="list__item" id="yexdr5_101"><p>Ajouter des `requirements` sur les param&egrave;tres et tester &agrave; nouveau</p></li></ol></section></section><div class="last-modified">Last modified: 01 février 2025</div><div data-feedback-placeholder="true"></div><div class="navigation-links _bottom"><a href="000-intro.html" class="navigation-links__prev">Introduction</a><a href="003-01-les-services.html" class="navigation-links__next">Les services</a></div></article><div id="disqus_thread"></div></div></section></main></div><script src="https://resources.jetbrains.com/writerside/apidoc/6.10.0-b575/app.js"></script></body></html>